import { useState, useEffect, useRef } from 'react'
import { storageService } from '../services/storageService'
import { encryptionService } from '../services/encryptionService'

export const useNotes = () => {
  const [notes, setNotes] = useState([])
  const [currentNote, setCurrentNote] = useState(null)
  const [searchQuery, setSearchQuery] = useState('')
  const [loading, setLoading] = useState(true)
  const autoSaveTimeoutRef = useRef(null)
  const lastSavedContentRef = useRef('')

  // Load notes on mount
  useEffect(() => {
    loadNotes()
  }, [])

  const loadNotes = () => {
    setLoading(true)
    const savedNotes = storageService.getNotes()
    setNotes(savedNotes)
    setLoading(false)
  }

  // Filter notes based on search
  const filteredNotes = notes.filter(note => 
    note.title.toLowerCase().includes(searchQuery.toLowerCase()) ||
    (!note.isEncrypted && note.content.toLowerCase().includes(searchQuery.toLowerCase()))
  )

  // Create new note
  const createNote = () => {
    const newNote = storageService.addNote({
      title: 'New Note',
      content: ''
    })
    setNotes(prev => [newNote, ...prev])
    setCurrentNote(newNote)
    // Reset the last saved content reference
    lastSavedContentRef.current = ''
    return newNote
  }

  // Update note
  const updateNote = (id, updates) => {
    const updatedNote = storageService.updateNote(id, updates)
    if (updatedNote) {
      setNotes(prev => prev.map(note => 
        note.id === id ? updatedNote : note
      ))
      if (currentNote?.id === id) {
        setCurrentNote(updatedNote)
      }
    }
    return updatedNote
  }

  // Delete note
  const deleteNote = (id) => {
    storageService.deleteNote(id)
    setNotes(prev => prev.filter(note => note.id !== id))
    if (currentNote?.id === id) {
      setCurrentNote(null)
    }
  }

  // Toggle pin
  const togglePin = (id) => {
    const updatedNote = storageService.togglePin(id)
    if (updatedNote) {
      loadNotes() // Reload to get proper sorting
      if (currentNote?.id === id) {
        setCurrentNote(updatedNote)
      }
    }
  }

  // Encrypt note
  const encryptNote = async (id, password) => {
    try {
      const note = notes.find(n => n.id === id)
      if (!note) throw new Error('Note not found')

      // Encrypt the content
      const encryptedContent = await encryptionService.encrypt(note.content, password)
      
      // Update note with encrypted data
      const updatedNote = storageService.updateNote(id, {
        content: encryptedContent,
        isEncrypted: true,
        encryptedAt: new Date().toISOString()
      })

      if (updatedNote) {
        setNotes(prev => prev.map(n => n.id === id ? updatedNote : n))
        if (currentNote?.id === id) {
          setCurrentNote({ ...updatedNote, content: 'ðŸ”’ This note is encrypted. Click to decrypt.' })
        }
      }

      return true
    } catch (error) {
      console.error('Encryption failed:', error)
      throw error
    }
  }

  // Decrypt note
  const decryptNote = async (id, password) => {
    try {
      const note = notes.find(n => n.id === id)
      if (!note || !note.isEncrypted) throw new Error('Note not found or not encrypted')

      // Decrypt the content
      const decryptedContent = await encryptionService.decrypt(note.content, password)
      
      // Update note with decrypted data
      const updatedNote = storageService.updateNote(id, {
        content: decryptedContent,
        isEncrypted: false,
        decryptedAt: new Date().toISOString()
      })

      if (updatedNote) {
        setNotes(prev => prev.map(n => n.id === id ? updatedNote : n))
        if (currentNote?.id === id) {
          setCurrentNote(updatedNote)
        }
      }

      return true
    } catch (error) {
      console.error('Decryption failed:', error)
      return false
    }
  }

  // Smart auto-save that preserves manual title changes
  const autoSave = (noteId, content) => {
    if (!noteId) return
    
    const note = notes.find(n => n.id === noteId)
    if (note?.isEncrypted) {
      // Don't auto-save encrypted notes
      return
    }

    // Clear existing timeout
    if (autoSaveTimeoutRef.current) {
      clearTimeout(autoSaveTimeoutRef.current)
    }

    // Debounced save
    autoSaveTimeoutRef.current = setTimeout(() => {
      // Only update title if it hasn't been manually changed
      const currentNoteData = notes.find(n => n.id === noteId)
      if (!currentNoteData) return

      // Extract text content for title generation
      const tempDiv = document.createElement('div')
      tempDiv.innerHTML = content
      const textContent = tempDiv.textContent || tempDiv.innerText || ''
      
      // Generate title from first line
      const firstLine = textContent.split('\n')[0].trim()
      const autoGeneratedTitle = firstLine.substring(0, 50) || 'Untitled Note'

      // Check if we should update the title
      let shouldUpdateTitle = false
      
      // Update title only if:
      // 1. Current title is default ("New Note" or "Untitled Note")
      // 2. Content has changed significantly and title seems auto-generated
      // 3. First substantial content is being added
      if (currentNoteData.title === 'New Note' || 
          currentNoteData.title === 'Untitled Note' ||
          (textContent.length > 10 && lastSavedContentRef.current.length < 10)) {
        shouldUpdateTitle = true
      }

      const updates = { content }
      
      if (shouldUpdateTitle && firstLine && firstLine.length > 3) {
        updates.title = autoGeneratedTitle
      }

      updateNote(noteId, updates)
      lastSavedContentRef.current = content
    }, 1000) // 1 second delay
  }

  // Cleanup timeout on unmount
  useEffect(() => {
    return () => {
      if (autoSaveTimeoutRef.current) {
        clearTimeout(autoSaveTimeoutRef.current)
      }
    }
  }, [])

  return {
    notes: filteredNotes,
    currentNote,
    searchQuery,
    loading,
    setCurrentNote,
    setSearchQuery,
    createNote,
    updateNote,
    deleteNote,
    togglePin,
    autoSave,
    encryptNote,
    decryptNote
  }
}